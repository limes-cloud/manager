// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.7.3
// - protoc             v4.24.4
// source: api/auth/proto/auth_service.proto

package auth

import (
	context "context"

	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var (
	_ = new(context.Context)
	_ = binding.EncodeURL
)

const _ = http.SupportPackageIsVersion1

const (
	OperationAuthAuth                = "/manager.api.auth.Auth/Auth"
	OperationAuthGetUserLoginCaptcha = "/manager.api.auth.Auth/GetUserLoginCaptcha"
	OperationAuthListLoginLog        = "/manager.api.auth.Auth/ListLoginLog"
	OperationAuthOAuthHandler        = "/manager.api.auth.Auth/OAuthHandler"
	OperationAuthUserLogin           = "/manager.api.auth.Auth/UserLogin"
	OperationAuthUserLogout          = "/manager.api.auth.Auth/UserLogout"
	OperationAuthUserRefreshToken    = "/manager.api.auth.Auth/UserRefreshToken"
)

type AuthHTTPServer interface {
	// Auth Auth 接口鉴权
	Auth(context.Context, *AuthRequest) (*AuthReply, error)
	// GetUserLoginCaptcha GetUserLoginCaptcha 获取用户登陆验证吗
	GetUserLoginCaptcha(context.Context, *emptypb.Empty) (*GetUserLoginCaptchaReply, error)
	// ListLoginLog ListLoginLog 获取用户登陆信息列表
	ListLoginLog(context.Context, *ListLoginLogRequest) (*ListLoginLogReply, error)
	// OAuthHandler OAuthHandler 渠道授权处理
	OAuthHandler(context.Context, *OAuthHandlerRequest) (*OAuthHandlerReply, error)
	// UserLogin UserLogin 用户登陆
	UserLogin(context.Context, *UserLoginRequest) (*UserLoginReply, error)
	// UserLogout UserLogout 用户退出
	UserLogout(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// UserRefreshToken UserRefreshToken 用户刷新token
	UserRefreshToken(context.Context, *emptypb.Empty) (*UserRefreshTokenReply, error)
}

func RegisterAuthHTTPServer(s *http.Server, srv AuthHTTPServer) {
	r := s.Route("/")
	r.POST("/manager/api/v1/auth", _Auth_Auth0_HTTP_Handler(srv))
	r.GET("/manager/api/v1/login/captcha", _Auth_GetUserLoginCaptcha0_HTTP_Handler(srv))
	r.POST("/manager/api/v1/login", _Auth_UserLogin0_HTTP_Handler(srv))
	r.POST("/manager/api/v1/logout", _Auth_UserLogout0_HTTP_Handler(srv))
	r.POST("/manager/api/v1/token/refresh", _Auth_UserRefreshToken0_HTTP_Handler(srv))
	r.GET("/manager/api/v1/login/logs", _Auth_ListLoginLog0_HTTP_Handler(srv))
	r.POST("/manager/api/v1/oauth/handler", _Auth_OAuthHandler0_HTTP_Handler(srv))
}

func _Auth_Auth0_HTTP_Handler(srv AuthHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in AuthRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationAuthAuth)
		h := ctx.Middleware(func(ctx context.Context, req any) (any, error) {
			return srv.Auth(ctx, req.(*AuthRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*AuthReply)
		return ctx.Result(200, reply)
	}
}

func _Auth_GetUserLoginCaptcha0_HTTP_Handler(srv AuthHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in emptypb.Empty
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationAuthGetUserLoginCaptcha)
		h := ctx.Middleware(func(ctx context.Context, req any) (any, error) {
			return srv.GetUserLoginCaptcha(ctx, req.(*emptypb.Empty))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetUserLoginCaptchaReply)
		return ctx.Result(200, reply)
	}
}

func _Auth_UserLogin0_HTTP_Handler(srv AuthHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UserLoginRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationAuthUserLogin)
		h := ctx.Middleware(func(ctx context.Context, req any) (any, error) {
			return srv.UserLogin(ctx, req.(*UserLoginRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UserLoginReply)
		return ctx.Result(200, reply)
	}
}

func _Auth_UserLogout0_HTTP_Handler(srv AuthHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in emptypb.Empty
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationAuthUserLogout)
		h := ctx.Middleware(func(ctx context.Context, req any) (any, error) {
			return srv.UserLogout(ctx, req.(*emptypb.Empty))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*emptypb.Empty)
		return ctx.Result(200, reply)
	}
}

func _Auth_UserRefreshToken0_HTTP_Handler(srv AuthHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in emptypb.Empty
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationAuthUserRefreshToken)
		h := ctx.Middleware(func(ctx context.Context, req any) (any, error) {
			return srv.UserRefreshToken(ctx, req.(*emptypb.Empty))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UserRefreshTokenReply)
		return ctx.Result(200, reply)
	}
}

func _Auth_ListLoginLog0_HTTP_Handler(srv AuthHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListLoginLogRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationAuthListLoginLog)
		h := ctx.Middleware(func(ctx context.Context, req any) (any, error) {
			return srv.ListLoginLog(ctx, req.(*ListLoginLogRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListLoginLogReply)
		return ctx.Result(200, reply)
	}
}

func _Auth_OAuthHandler0_HTTP_Handler(srv AuthHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in OAuthHandlerRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationAuthOAuthHandler)
		h := ctx.Middleware(func(ctx context.Context, req any) (any, error) {
			return srv.OAuthHandler(ctx, req.(*OAuthHandlerRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*OAuthHandlerReply)
		return ctx.Result(200, reply)
	}
}

type AuthHTTPClient interface {
	Auth(ctx context.Context, req *AuthRequest, opts ...http.CallOption) (rsp *AuthReply, err error)
	GetUserLoginCaptcha(ctx context.Context, req *emptypb.Empty, opts ...http.CallOption) (rsp *GetUserLoginCaptchaReply, err error)
	ListLoginLog(ctx context.Context, req *ListLoginLogRequest, opts ...http.CallOption) (rsp *ListLoginLogReply, err error)
	OAuthHandler(ctx context.Context, req *OAuthHandlerRequest, opts ...http.CallOption) (rsp *OAuthHandlerReply, err error)
	UserLogin(ctx context.Context, req *UserLoginRequest, opts ...http.CallOption) (rsp *UserLoginReply, err error)
	UserLogout(ctx context.Context, req *emptypb.Empty, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
	UserRefreshToken(ctx context.Context, req *emptypb.Empty, opts ...http.CallOption) (rsp *UserRefreshTokenReply, err error)
}

type AuthHTTPClientImpl struct {
	cc *http.Client
}

func NewAuthHTTPClient(client *http.Client) AuthHTTPClient {
	return &AuthHTTPClientImpl{client}
}

func (c *AuthHTTPClientImpl) Auth(ctx context.Context, in *AuthRequest, opts ...http.CallOption) (*AuthReply, error) {
	var out AuthReply
	pattern := "/manager/api/v1/auth"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationAuthAuth))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AuthHTTPClientImpl) GetUserLoginCaptcha(ctx context.Context, in *emptypb.Empty, opts ...http.CallOption) (*GetUserLoginCaptchaReply, error) {
	var out GetUserLoginCaptchaReply
	pattern := "/manager/api/v1/login/captcha"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationAuthGetUserLoginCaptcha))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AuthHTTPClientImpl) ListLoginLog(ctx context.Context, in *ListLoginLogRequest, opts ...http.CallOption) (*ListLoginLogReply, error) {
	var out ListLoginLogReply
	pattern := "/manager/api/v1/login/logs"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationAuthListLoginLog))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AuthHTTPClientImpl) OAuthHandler(ctx context.Context, in *OAuthHandlerRequest, opts ...http.CallOption) (*OAuthHandlerReply, error) {
	var out OAuthHandlerReply
	pattern := "/manager/api/v1/oauth/handler"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationAuthOAuthHandler))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AuthHTTPClientImpl) UserLogin(ctx context.Context, in *UserLoginRequest, opts ...http.CallOption) (*UserLoginReply, error) {
	var out UserLoginReply
	pattern := "/manager/api/v1/login"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationAuthUserLogin))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AuthHTTPClientImpl) UserLogout(ctx context.Context, in *emptypb.Empty, opts ...http.CallOption) (*emptypb.Empty, error) {
	var out emptypb.Empty
	pattern := "/manager/api/v1/logout"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationAuthUserLogout))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *AuthHTTPClientImpl) UserRefreshToken(ctx context.Context, in *emptypb.Empty, opts ...http.CallOption) (*UserRefreshTokenReply, error) {
	var out UserRefreshTokenReply
	pattern := "/manager/api/v1/token/refresh"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationAuthUserRefreshToken))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
